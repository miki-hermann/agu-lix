+++ SPECIFICATION --- bidirectional branch, version 0.99
+++ Parameters:
    ===========
+++ input       = 54-power-in.txt
+++ output      = 54-power-out.txt
+++ trace       = 3
+++ direction   = first-to-last
+++ drop        = yes
+++ verbose     = 3
+++ split       = 4
+++ loop limit  = 100
+++ stdlib      = /usr/local/lib/indy/stdlib/
-----------------------------------------------------------------------

+++ specification POWER from 54-power-in.txt successfully parsed
+++ Listing
         1: specification POWER
         2: sorts
         3:      exp nat
         4: constructors
         5:      0: -> nat
         6:      1: -> exp
         7:      s: nat -> nat
         8:      sexp: exp -> exp
         9: defined functions
        10:      *: nat nat -> nat
        11:      +: nat nat -> nat
        12:      power: nat exp -> nat
        13: precedence
        14:      power > * > + > s = sexp > 0 = 1
        15: axioms
        16:      x * 0 = 0;
        17:      x + 0 = x;
        18:      power(x, 1) = x;
        19:      x + s(y) = s(x + y);
        20:      x * s(y) = (x * y) + x;
        21:      power(x, sexp(ye)) = x * power(x, ye);
        22: conjectures
        23:      power(x * y, ze) = power(x, ze) * power(y, ze);
        24: end
+++ finitary sorts: <empty>
+++ Rewrite System 
	x * 0 -> 0
	x + 0 -> x
	power(x, 1) -> x
	x + s(y) -> s(x + y)
	x * s(y) -> (x * y) + x
	power(x, sexp(ye)) -> x * power(x, ye)
+++ inductive positions:
... for *: 1
... for +: 1
... for power: 1
+++ maximal depths of left-hand sides:
... for power: 2
... for +: 2
... for *: 2
+++ general maximal depth = 2
+++ sort dependence: <empty>
+++ test sets for defined functions and sorts:
... for power
... ... exp
		1
		sexp(x)
... for +
... ... nat
		0
		s(x)
... for *
... ... nat
		0
		s(x)

+++ conjecture(s)
	power(x * y, ze) = power(x, ze) * power(y, ze)

+++ inference system initiated
+++ treating clause
	power(x * y, ze) = power(x, ze) * power(y, ze)
+++ inductive narrowing on conjecture
	power(x * y, ze) = power(x, ze) * power(y, ze)
... induction variables of
	power(x * y, ze) = power(x, ze) * power(y, ze)
... are:
	y:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(x * y, ze) = power(x, ze) * power(y, ze)
... with variable y
+++ creating new conjecture
	power(x * 0, ze) = power(x, ze) * power(0, ze)
+++ creating new conjecture
	power(x * s(xts), ze) = power(x, ze) * power(s(xts), ze)
--- clause
	power(x * 0, ze) = power(x, ze) * power(0, ze)
... reduced in 1 step to
	power(0, ze) = power(x, ze) * power(0, ze)
--- clause
	power(x * s(xts), ze) = power(x, ze) * power(s(xts), ze)
... reduced in 1 step to
	power((x * xts) + x, ze) = power(x, ze) * power(s(xts), ze)
+++ inductive narrowing succeeded
--- clause
	power(x * y, ze) = power(x, ze) * power(y, ze)
... oriented to rule
	power(x * y, ze) -> power(x, ze) * power(y, ze)
+++ added new clause(s)
	power(0, ze) = power(x, ze) * power(0, ze)
	power((x * xts) + x, ze) = power(x, ze) * power(s(xts), ze)
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(0, ze) = power(x, ze) * power(0, ze)
	power((x * xts) + x, ze) = power(x, ze) * power(s(xts), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x * y, ze) -> power(x, ze) * power(y, ze)
--- Primal Grammar:
	<empty>

+++ treating clause
	power(0, ze) = power(x, ze) * power(0, ze)
+++ inductive narrowing on conjecture
	power(0, ze) = power(x, ze) * power(0, ze)
... induction variables of
	power(0, ze) = power(x, ze) * power(0, ze)
... are:
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(0, ze) = power(x, ze) * power(0, ze)
... with variable ze
+++ creating new conjecture
	power(0, 1) = power(x, 1) * power(0, 1)
+++ creating new conjecture
	power(0, sexp(xts)) = power(x, sexp(xts)) * power(0, sexp(xts))
--- clause
	power(0, 1) = power(x, 1) * power(0, 1)
... reduced to tautology
	0 = 0
--- clause
	power(0, sexp(xts)) = power(x, sexp(xts)) * power(0, sexp(xts))
... reduced in 3 steps to
	0 * power(0, xts) = (x * power(x, xts)) * (0 * power(0, xts))
+++ inductive narrowing succeeded
--- clause
	power(0, ze) = power(x, ze) * power(0, ze)
... oriented to rule
	power(x, ze) * power(0, ze) -> power(0, ze)
+++ added new clause(s)
	0 * power(0, xts) = (x * power(x, xts)) * (0 * power(0, xts))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power((x * xts) + x, ze) = power(x, ze) * power(s(xts), ze)
	0 * power(0, xts) = (x * power(x, xts)) * (0 * power(0, xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
--- Primal Grammar:
	<empty>

+++ treating clause
	power((x * xts) + x, ze) = power(x, ze) * power(s(xts), ze)
+++ inductive narrowing on conjecture
	power((x * xts) + x, ze) = power(x, ze) * power(s(xts), ze)
... induction variables of
	power((x * xts) + x, ze) = power(x, ze) * power(s(xts), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power((x * xts) + x, ze) = power(x, ze) * power(s(xts), ze)
... with variable xts
+++ creating new conjecture
	power((x * 0) + x, ze) = power(x, ze) * power(s(0), ze)
+++ creating new conjecture
	power((x * s(xts)) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
--- clause
	power((x * 0) + x, ze) = power(x, ze) * power(s(0), ze)
... reduced in 1 step to
	power(0 + x, ze) = power(x, ze) * power(s(0), ze)
--- clause
	power((x * s(xts)) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
... reduced in 1 step to
	power(((x * xts) + x) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
+++ inductive narrowing succeeded
--- clause
	power((x * xts) + x, ze) = power(x, ze) * power(s(xts), ze)
... oriented to rule
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
+++ added new clause(s)
	power(0 + x, ze) = power(x, ze) * power(s(0), ze)
	power(((x * xts) + x) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	0 * power(0, xts) = (x * power(x, xts)) * (0 * power(0, xts))
	power(0 + x, ze) = power(x, ze) * power(s(0), ze)
	power(((x * xts) + x) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
--- Primal Grammar:
	<empty>

+++ treating clause
	0 * power(0, xts) = (x * power(x, xts)) * (0 * power(0, xts))
+++ inductive narrowing on conjecture
	0 * power(0, xts) = (x * power(x, xts)) * (0 * power(0, xts))
... induction variables of
	0 * power(0, xts) = (x * power(x, xts)) * (0 * power(0, xts))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * power(0, xts) = (x * power(x, xts)) * (0 * power(0, xts))
... with variable xts
+++ creating new conjecture
	0 * power(0, 1) = (x * power(x, 1)) * (0 * power(0, 1))
+++ creating new conjecture
	0 * power(0, sexp(xts)) = (x * power(x, sexp(xts))) * (0 * power(0, sexp(xts)))
--- clause
	0 * power(0, 1) = (x * power(x, 1)) * (0 * power(0, 1))
... reduced to tautology
	0 = 0
--- clause
	0 * power(0, sexp(xts)) = (x * power(x, sexp(xts))) * (0 * power(0, sexp(xts)))
... reduced in 3 steps to
	0 * (0 * power(0, xts)) = (x * (x * power(x, xts))) * (0 * (0 * power(0, xts)))
+++ inductive narrowing succeeded
--- clause
	0 * power(0, xts) = (x * power(x, xts)) * (0 * power(0, xts))
... oriented to rule
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
+++ added new clause(s)
	0 * (0 * power(0, xts)) = (x * (x * power(x, xts))) * (0 * (0 * power(0, xts)))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(0 + x, ze) = power(x, ze) * power(s(0), ze)
	power(((x * xts) + x) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
	0 * (0 * power(0, xts)) = (x * (x * power(x, xts))) * (0 * (0 * power(0, xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
--- Primal Grammar:
	<empty>

+++ treating clause
	power(0 + x, ze) = power(x, ze) * power(s(0), ze)
+++ inductive narrowing on conjecture
	power(0 + x, ze) = power(x, ze) * power(s(0), ze)
... induction variables of
	power(0 + x, ze) = power(x, ze) * power(s(0), ze)
... are:
	x:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(0 + x, ze) = power(x, ze) * power(s(0), ze)
... with variable x
+++ creating new conjecture
	power(0 + 0, ze) = power(0, ze) * power(s(0), ze)
+++ creating new conjecture
	power(0 + s(xts), ze) = power(s(xts), ze) * power(s(0), ze)
--- clause
	power(0 + 0, ze) = power(0, ze) * power(s(0), ze)
... reduced in 1 step to
	power(0, ze) = power(0, ze) * power(s(0), ze)
--- clause
	power(0 + s(xts), ze) = power(s(xts), ze) * power(s(0), ze)
... reduced in 1 step to
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
+++ inductive narrowing succeeded
--- clause
	power(0 + x, ze) = power(x, ze) * power(s(0), ze)
... oriented to rule
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
+++ added new clause(s)
	power(0, ze) = power(0, ze) * power(s(0), ze)
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(((x * xts) + x) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
	0 * (0 * power(0, xts)) = (x * (x * power(x, xts))) * (0 * (0 * power(0, xts)))
	power(0, ze) = power(0, ze) * power(s(0), ze)
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
--- Primal Grammar:
	<empty>

+++ treating clause
	power(((x * xts) + x) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
+++ inductive narrowing on conjecture
	power(((x * xts) + x) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
... induction variables of
	power(((x * xts) + x) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(((x * xts) + x) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
... with variable xts
+++ creating new conjecture
	power(((x * 0) + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
+++ creating new conjecture
	power(((x * s(xts)) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
--- clause
	power(((x * 0) + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
... reduced in 1 step to
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
--- clause
	power(((x * s(xts)) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
... reduced in 1 step to
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
+++ inductive narrowing succeeded
--- clause
	power(((x * xts) + x) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
... oriented to rule
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
+++ added new clause(s)
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	0 * (0 * power(0, xts)) = (x * (x * power(x, xts))) * (0 * (0 * power(0, xts)))
	power(0, ze) = power(0, ze) * power(s(0), ze)
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
--- Primal Grammar:
	<empty>

+++ treating clause
	0 * (0 * power(0, xts)) = (x * (x * power(x, xts))) * (0 * (0 * power(0, xts)))
+++ inductive narrowing on conjecture
	0 * (0 * power(0, xts)) = (x * (x * power(x, xts))) * (0 * (0 * power(0, xts)))
... induction variables of
	0 * (0 * power(0, xts)) = (x * (x * power(x, xts))) * (0 * (0 * power(0, xts)))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * (0 * power(0, xts)) = (x * (x * power(x, xts))) * (0 * (0 * power(0, xts)))
... with variable xts
+++ creating new conjecture
	0 * (0 * power(0, 1)) = (x * (x * power(x, 1))) * (0 * (0 * power(0, 1)))
+++ creating new conjecture
	0 * (0 * power(0, sexp(xts))) = (x * (x * power(x, sexp(xts)))) * (0 * (0 * power(0, sexp(xts))))
--- clause
	0 * (0 * power(0, 1)) = (x * (x * power(x, 1))) * (0 * (0 * power(0, 1)))
... reduced to tautology
	0 = 0
--- clause
	0 * (0 * power(0, sexp(xts))) = (x * (x * power(x, sexp(xts)))) * (0 * (0 * power(0, sexp(xts))))
... reduced in 3 steps to
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
+++ inductive narrowing succeeded
--- clause
	0 * (0 * power(0, xts)) = (x * (x * power(x, xts))) * (0 * (0 * power(0, xts)))
... oriented to rule
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
+++ added new clause(s)
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(0, ze) = power(0, ze) * power(s(0), ze)
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
--- Primal Grammar:
	<empty>

+++ treating clause
	power(0, ze) = power(0, ze) * power(s(0), ze)
+++ inductive narrowing on conjecture
	power(0, ze) = power(0, ze) * power(s(0), ze)
... induction variables of
	power(0, ze) = power(0, ze) * power(s(0), ze)
... are:
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(0, ze) = power(0, ze) * power(s(0), ze)
... with variable ze
+++ creating new conjecture
	power(0, 1) = power(0, 1) * power(s(0), 1)
+++ creating new conjecture
	power(0, sexp(xts)) = power(0, sexp(xts)) * power(s(0), sexp(xts))
--- clause
	power(0, 1) = power(0, 1) * power(s(0), 1)
... reduced to tautology
	0 = 0
--- clause
	power(0, sexp(xts)) = power(0, sexp(xts)) * power(s(0), sexp(xts))
... reduced in 3 steps to
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
+++ inductive narrowing succeeded
--- clause
	power(0, ze) = power(0, ze) * power(s(0), ze)
... oriented to rule
	power(0, ze) * power(s(0), ze) -> power(0, ze)
+++ added new clause(s)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
--- Primal Grammar:
	<empty>

+++ treating clause
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
+++ inductive narrowing on conjecture
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
... induction variables of
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
... with variable xts
+++ creating new conjecture
	power(s(0 + 0), ze) = power(s(0), ze) * power(s(0), ze)
+++ creating new conjecture
	power(s(0 + s(xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
--- clause
	power(s(0 + 0), ze) = power(s(0), ze) * power(s(0), ze)
... reduced in 1 step to
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
--- clause
	power(s(0 + s(xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
... reduced in 1 step to
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
+++ inductive narrowing succeeded
--- clause
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
... oriented to rule
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
+++ added new clause(s)
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
--- Primal Grammar:
	<empty>

+++ treating clause
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
+++ inductive narrowing on conjecture
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
... induction variables of
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
... are:
	x:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
... with variable x
+++ creating new conjecture
	power((0 + 0) + 0, ze) = power(0, ze) * power(s(s(0)), ze)
+++ creating new conjecture
	power((0 + s(xts)) + s(xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
--- clause
	power((0 + 0) + 0, ze) = power(0, ze) * power(s(s(0)), ze)
... reduced in 2 steps to
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
--- clause
	power((0 + s(xts)) + s(xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
... reduced in 2 steps to
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
+++ inductive narrowing succeeded
--- clause
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
... oriented to rule
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
+++ added new clause(s)
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
--- Primal Grammar:
	<empty>

+++ treating clause
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
+++ inductive narrowing on conjecture
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
... induction variables of
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
... with variable xts
+++ creating new conjecture
	power((((x * 0) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
+++ creating new conjecture
	power((((x * s(xts)) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(s(xts)))), ze)
--- clause
	power((((x * 0) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
... reduced in 1 step to
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
--- clause
	power((((x * s(xts)) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(s(xts)))), ze)
... reduced in 1 step to
	power(((((x * xts) + x) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(s(xts)))), ze)
+++ inductive narrowing succeeded
--- clause
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
... oriented to rule
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
+++ added new clause(s)
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
	power(((((x * xts) + x) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(s(xts)))), ze)
... to conjectures
+++ active wrap
	power(. + x, ze) = power(x, ze) * power(s(.), ze)
... with sequence
	power((x * xts) + x, ze) = power(x, ze) * power(s(xts), ze)
	power(((x * xts) + x) + x, ze) = power(x, ze) * power(s(s(xts)), ze)
	power((((x * xts) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(xts))), ze)
+++ primal grammar found for head
	{*, +, power, s}
... and wrap
	power(. + x, ze) = power(x, ze) * power(s(.), ze)
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
--- clause
	power(((((x * xts) + x) + x) + x) + x, ze) = power(x, ze) * power(s(s(s(s(xts)))), ze)
... subsumed by lemma
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)

+++ treating clause
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
+++ inductive narrowing on conjecture
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
... induction variables of
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
... with variable xts
+++ creating new conjecture
	0 * (0 * (0 * power(0, 1))) = (x * (x * (x * power(x, 1)))) * (0 * (0 * (0 * power(0, 1))))
+++ creating new conjecture
	0 * (0 * (0 * power(0, sexp(xts)))) = (x * (x * (x * power(x, sexp(xts))))) * (0 * (0 * (0 * power(0, sexp(xts)))))
--- clause
	0 * (0 * (0 * power(0, 1))) = (x * (x * (x * power(x, 1)))) * (0 * (0 * (0 * power(0, 1))))
... reduced to tautology
	0 = 0
--- clause
	0 * (0 * (0 * power(0, sexp(xts)))) = (x * (x * (x * power(x, sexp(xts))))) * (0 * (0 * (0 * power(0, sexp(xts)))))
... reduced in 3 steps to
	0 * (0 * (0 * (0 * power(0, xts)))) = (x * (x * (x * (x * power(x, xts))))) * (0 * (0 * (0 * (0 * power(0, xts)))))
+++ inductive narrowing succeeded
--- clause
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
... oriented to rule
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
+++ added new clause(s)
	0 * (0 * (0 * (0 * power(0, xts)))) = (x * (x * (x * (x * power(x, xts))))) * (0 * (0 * (0 * (0 * power(0, xts)))))
... to conjectures
+++ active wrap
	0 * . = (x * .) * (0 * .)
... with sequence
	0 * power(0, xts) = (x * power(x, xts)) * (0 * power(0, xts))
	0 * (0 * power(0, xts)) = (x * (x * power(x, xts))) * (0 * (0 * power(0, xts)))
	0 * (0 * (0 * power(0, xts))) = (x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts))))
+++ primal grammar found for head
	{*, 0, power}
... and wrap
	0 * . = (x * .) * (0 * .)
+++ Presburger system  = {
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
+++ }
+++ Lemma(s)           = 
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
--- clause
	0 * (0 * (0 * (0 * power(0, xts)))) = (x * (x * (x * (x * power(x, xts))))) * (0 * (0 * (0 * (0 * power(0, xts)))))
... subsumed by lemma
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))

+++ treating clause
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
+++ inductive narrowing on conjecture
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
... induction variables of
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
... with variable xts
+++ creating new conjecture
	0 * power(0, 1) = (0 * power(0, 1)) * (s(0) * power(s(0), 1))
+++ creating new conjecture
	0 * power(0, sexp(xts)) = (0 * power(0, sexp(xts))) * (s(0) * power(s(0), sexp(xts)))
--- clause
	0 * power(0, 1) = (0 * power(0, 1)) * (s(0) * power(s(0), 1))
... reduced to tautology
	0 = 0
--- clause
	0 * power(0, sexp(xts)) = (0 * power(0, sexp(xts))) * (s(0) * power(s(0), sexp(xts)))
... reduced in 3 steps to
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
+++ inductive narrowing succeeded
--- clause
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
... oriented to rule
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
+++ added new clause(s)
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))

+++ treating clause
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
+++ inductive narrowing on conjecture
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
... induction variables of
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
... are:
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
... with variable ze
+++ creating new conjecture
	power(s(0), 1) = power(s(0), 1) * power(s(0), 1)
+++ creating new conjecture
	power(s(0), sexp(xts)) = power(s(0), sexp(xts)) * power(s(0), sexp(xts))
--- clause
	power(s(0), 1) = power(s(0), 1) * power(s(0), 1)
... reduced to tautology
	s(0) = s(0)
--- clause
	power(s(0), sexp(xts)) = power(s(0), sexp(xts)) * power(s(0), sexp(xts))
... reduced in 3 steps to
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
+++ inductive narrowing succeeded
--- clause
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
... oriented to rule
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
+++ added new clause(s)
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))

+++ treating clause
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
+++ inductive narrowing on conjecture
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
... induction variables of
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
... with variable xts
+++ creating new conjecture
	power(s(s(0 + 0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
+++ creating new conjecture
	power(s(s(0 + s(xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
--- clause
	power(s(s(0 + 0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
... reduced in 1 step to
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
--- clause
	power(s(s(0 + s(xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
... reduced in 1 step to
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
+++ inductive narrowing succeeded
--- clause
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
... oriented to rule
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
+++ added new clause(s)
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))

+++ treating clause
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
+++ inductive narrowing on conjecture
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
... induction variables of
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
... are:
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
... with variable ze
+++ creating new conjecture
	power(0, 1) = power(0, 1) * power(s(s(0)), 1)
+++ creating new conjecture
	power(0, sexp(xts)) = power(0, sexp(xts)) * power(s(s(0)), sexp(xts))
--- clause
	power(0, 1) = power(0, 1) * power(s(s(0)), 1)
... reduced to tautology
	0 = 0
--- clause
	power(0, sexp(xts)) = power(0, sexp(xts)) * power(s(s(0)), sexp(xts))
... reduced in 3 steps to
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
+++ inductive narrowing succeeded
--- clause
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
... oriented to rule
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
+++ added new clause(s)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))

+++ treating clause
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
+++ inductive narrowing on conjecture
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
... induction variables of
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
... with variable xts
+++ creating new conjecture
	power(s(s(0 + 0) + 0), ze) = power(s(0), ze) * power(s(s(0)), ze)
+++ creating new conjecture
	power(s(s(0 + s(xts)) + s(xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
--- clause
	power(s(s(0 + 0) + 0), ze) = power(s(0), ze) * power(s(s(0)), ze)
... reduced in 2 steps to
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
--- clause
	power(s(s(0 + s(xts)) + s(xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
... reduced in 2 steps to
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
+++ inductive narrowing succeeded
--- clause
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
... oriented to rule
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
+++ added new clause(s)
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))

+++ treating clause
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
+++ inductive narrowing on conjecture
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
... induction variables of
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
... are:
	x:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
... with variable x
+++ creating new conjecture
	power(((0 + 0) + 0) + 0, ze) = power(0, ze) * power(s(s(s(0))), ze)
+++ creating new conjecture
	power(((0 + s(xts)) + s(xts)) + s(xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
--- clause
	power(((0 + 0) + 0) + 0, ze) = power(0, ze) * power(s(s(s(0))), ze)
... reduced in 3 steps to
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
--- clause
	power(((0 + s(xts)) + s(xts)) + s(xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
... reduced in 3 steps to
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
+++ inductive narrowing succeeded
--- clause
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
... oriented to rule
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
+++ added new clause(s)
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
... to conjectures
+++ active wrap
	power(. + x, ze) = power(x, ze) * power(s(.), ze)
... with sequence
	power(0 + x, ze) = power(x, ze) * power(s(0), ze)
	power((0 + x) + x, ze) = power(x, ze) * power(s(s(0)), ze)
	power(((0 + x) + x) + x, ze) = power(x, ze) * power(s(s(s(0))), ze)
+++ primal grammar found for head
	{*, +, 0, power, s}
... and wrap
	power(. + x, ze) = power(x, ze) * power(s(.), ze)
+++ Presburger system  = {
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)

+++ Status of the Inference System
--- Conjectures:
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)

+++ treating clause
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
+++ inductive narrowing on conjecture
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
... induction variables of
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
... with variable xts
+++ creating new conjecture
	0 * (0 * power(0, 1)) = (0 * (0 * power(0, 1))) * (s(0) * (s(0) * power(s(0), 1)))
+++ creating new conjecture
	0 * (0 * power(0, sexp(xts))) = (0 * (0 * power(0, sexp(xts)))) * (s(0) * (s(0) * power(s(0), sexp(xts))))
--- clause
	0 * (0 * power(0, 1)) = (0 * (0 * power(0, 1))) * (s(0) * (s(0) * power(s(0), 1)))
... reduced to tautology
	0 = 0
--- clause
	0 * (0 * power(0, sexp(xts))) = (0 * (0 * power(0, sexp(xts)))) * (s(0) * (s(0) * power(s(0), sexp(xts))))
... reduced in 3 steps to
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
+++ inductive narrowing succeeded
--- clause
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
... oriented to rule
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
+++ added new clause(s)
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)

+++ treating clause
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
+++ inductive narrowing on conjecture
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
... induction variables of
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
... with variable xts
+++ creating new conjecture
	s(0) * power(s(0), 1) = (s(0) * power(s(0), 1)) * (s(0) * power(s(0), 1))
+++ creating new conjecture
	s(0) * power(s(0), sexp(xts)) = (s(0) * power(s(0), sexp(xts))) * (s(0) * power(s(0), sexp(xts)))
--- clause
	s(0) * power(s(0), 1) = (s(0) * power(s(0), 1)) * (s(0) * power(s(0), 1))
... reduced to tautology
	s(0) = s(0)
--- clause
	s(0) * power(s(0), sexp(xts)) = (s(0) * power(s(0), sexp(xts))) * (s(0) * power(s(0), sexp(xts)))
... reduced in 3 steps to
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
+++ inductive narrowing succeeded
--- clause
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
... oriented to rule
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
+++ added new clause(s)
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)

+++ treating clause
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
+++ inductive narrowing on conjecture
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
... induction variables of
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
... are:
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
... with variable ze
+++ creating new conjecture
	power(s(s(0)), 1) = power(s(s(0)), 1) * power(s(0), 1)
+++ creating new conjecture
	power(s(s(0)), sexp(xts)) = power(s(s(0)), sexp(xts)) * power(s(0), sexp(xts))
--- clause
	power(s(s(0)), 1) = power(s(s(0)), 1) * power(s(0), 1)
... reduced to tautology
	s(s(0)) = s(s(0))
--- clause
	power(s(s(0)), sexp(xts)) = power(s(s(0)), sexp(xts)) * power(s(0), sexp(xts))
... reduced in 3 steps to
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
+++ inductive narrowing succeeded
--- clause
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
... oriented to rule
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
+++ added new clause(s)
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
... to conjectures
+++ active wrap
	power(., ze) = power(., ze) * power(s(0), ze)
... with sequence
	power(0, ze) = power(0, ze) * power(s(0), ze)
	power(s(0), ze) = power(s(0), ze) * power(s(0), ze)
	power(s(s(0)), ze) = power(s(s(0)), ze) * power(s(0), ze)
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	power(., ze) = power(., ze) * power(s(0), ze)
+++ Presburger system  = {
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)

+++ Status of the Inference System
--- Conjectures:
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)

+++ treating clause
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
+++ inductive narrowing on conjecture
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
... induction variables of
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
... with variable xts
+++ creating new conjecture
	power(s(s(s(0 + 0))), ze) = power(s(s(s(0))), ze) * power(s(0), ze)
+++ creating new conjecture
	power(s(s(s(0 + s(xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(0), ze)
--- clause
	power(s(s(s(0 + 0))), ze) = power(s(s(s(0))), ze) * power(s(0), ze)
... reduced in 1 step to
	power(s(s(s(0))), ze) = power(s(s(s(0))), ze) * power(s(0), ze)
--- clause
	power(s(s(s(0 + s(xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(0), ze)
... reduced in 1 step to
	power(s(s(s(s(0 + xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(0), ze)
--- clause
	power(s(s(s(0))), ze) = power(s(s(s(0))), ze) * power(s(0), ze)
... subsumed by lemma
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
... with substitution
	$n <- 3
+++ inductive narrowing succeeded
--- clause
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
... oriented to rule
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
+++ added new clause(s)
	power(s(s(s(s(0 + xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(0), ze)
... to conjectures
+++ active wrap
	power(., ze) = power(., ze) * power(s(0), ze)
... with sequence
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
	power(s(s(0 + xts)), ze) = power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(0 + xts))), ze) = power(s(s(s(xts))), ze) * power(s(0), ze)
+++ primal grammar found for head
	{*, +, 0, power, s}
... and wrap
	power(., ze) = power(., ze) * power(s(0), ze)
+++ Presburger system  = {
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
--- clause
	power(s(s(s(s(0 + xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(0), ze)
... subsumed by lemma
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)

+++ treating clause
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
+++ inductive narrowing on conjecture
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
... induction variables of
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
... with variable xts
+++ creating new conjecture
	0 * power(0, 1) = (0 * power(0, 1)) * (s(s(0)) * power(s(s(0)), 1))
+++ creating new conjecture
	0 * power(0, sexp(xts)) = (0 * power(0, sexp(xts))) * (s(s(0)) * power(s(s(0)), sexp(xts)))
--- clause
	0 * power(0, 1) = (0 * power(0, 1)) * (s(s(0)) * power(s(s(0)), 1))
... reduced to tautology
	0 = 0
--- clause
	0 * power(0, sexp(xts)) = (0 * power(0, sexp(xts))) * (s(s(0)) * power(s(s(0)), sexp(xts)))
... reduced in 3 steps to
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
+++ inductive narrowing succeeded
--- clause
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
... oriented to rule
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
+++ added new clause(s)
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)

+++ treating clause
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
+++ inductive narrowing on conjecture
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
... induction variables of
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
... are:
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
... with variable ze
+++ creating new conjecture
	power(s(s(0)), 1) = power(s(0), 1) * power(s(s(0)), 1)
+++ creating new conjecture
	power(s(s(0)), sexp(xts)) = power(s(0), sexp(xts)) * power(s(s(0)), sexp(xts))
--- clause
	power(s(s(0)), 1) = power(s(0), 1) * power(s(s(0)), 1)
... reduced to tautology
	s(s(0)) = s(s(0))
--- clause
	power(s(s(0)), sexp(xts)) = power(s(0), sexp(xts)) * power(s(s(0)), sexp(xts))
... reduced in 3 steps to
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
+++ inductive narrowing succeeded
--- clause
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
... oriented to rule
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
+++ added new clause(s)
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)

+++ treating clause
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
+++ inductive narrowing on conjecture
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
... induction variables of
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
... with variable xts
+++ creating new conjecture
	power(s(s(s(s(0 + 0)) + 0)), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
+++ creating new conjecture
	power(s(s(s(s(0 + s(xts))) + s(xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
--- clause
	power(s(s(s(s(0 + 0)) + 0)), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
... reduced in 2 steps to
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
--- clause
	power(s(s(s(s(0 + s(xts))) + s(xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
... reduced in 2 steps to
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
+++ inductive narrowing succeeded
--- clause
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
... oriented to rule
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
+++ added new clause(s)
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)

+++ treating clause
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
+++ inductive narrowing on conjecture
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
... induction variables of
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
... are:
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
... with variable ze
+++ creating new conjecture
	power(0, 1) = power(0, 1) * power(s(s(s(0))), 1)
+++ creating new conjecture
	power(0, sexp(xts)) = power(0, sexp(xts)) * power(s(s(s(0))), sexp(xts))
--- clause
	power(0, 1) = power(0, 1) * power(s(s(s(0))), 1)
... reduced to tautology
	0 = 0
--- clause
	power(0, sexp(xts)) = power(0, sexp(xts)) * power(s(s(s(0))), sexp(xts))
... reduced in 3 steps to
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
+++ inductive narrowing succeeded
--- clause
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
... oriented to rule
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
+++ added new clause(s)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... to conjectures
+++ active wrap
	power(0, ze) = power(0, ze) * power(s(.), ze)
... with sequence
	power(0, ze) = power(0, ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	power(0, ze) = power(0, ze) * power(s(.), ze)
+++ Presburger system  = {
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)

+++ Status of the Inference System
--- Conjectures:
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)

+++ treating clause
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
+++ inductive narrowing on conjecture
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
... induction variables of
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
... with variable xts
+++ creating new conjecture
	power(s(s(s(0 + 0) + 0) + 0), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
+++ creating new conjecture
	power(s(s(s(0 + s(xts)) + s(xts)) + s(xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
--- clause
	power(s(s(s(0 + 0) + 0) + 0), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
... reduced in 3 steps to
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
--- clause
	power(s(s(s(0 + s(xts)) + s(xts)) + s(xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
... reduced in 3 steps to
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
+++ inductive narrowing succeeded
--- clause
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
... oriented to rule
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
+++ added new clause(s)
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
... to conjectures
+++ active wrap
	power(s(. + xts), ze) = power(s(xts), ze) * power(s(.), ze)
... with sequence
	power(s(0 + xts), ze) = power(s(xts), ze) * power(s(0), ze)
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
+++ primal grammar found for head
	{*, +, 0, power, s}
... and wrap
	power(s(. + xts), ze) = power(s(xts), ze) * power(s(.), ze)
+++ Presburger system  = {
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)

+++ Status of the Inference System
--- Conjectures:
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)

+++ treating clause
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
+++ inductive narrowing on conjecture
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... induction variables of
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... with variable xts
+++ creating new conjecture
	0 * (0 * (0 * power(0, 1))) = (0 * (0 * (0 * power(0, 1)))) * (s(0) * (s(0) * (s(0) * power(s(0), 1))))
+++ creating new conjecture
	0 * (0 * (0 * power(0, sexp(xts)))) = (0 * (0 * (0 * power(0, sexp(xts))))) * (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts)))))
--- clause
	0 * (0 * (0 * power(0, 1))) = (0 * (0 * (0 * power(0, 1)))) * (s(0) * (s(0) * (s(0) * power(s(0), 1))))
... reduced to tautology
	0 = 0
--- clause
	0 * (0 * (0 * power(0, sexp(xts)))) = (0 * (0 * (0 * power(0, sexp(xts))))) * (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts)))))
... reduced in 3 steps to
	0 * (0 * (0 * (0 * power(0, xts)))) = (0 * (0 * (0 * (0 * power(0, xts))))) * (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))))
+++ inductive narrowing succeeded
--- clause
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... oriented to rule
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
+++ added new clause(s)
	0 * (0 * (0 * (0 * power(0, xts)))) = (0 * (0 * (0 * (0 * power(0, xts))))) * (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))))
... to conjectures
+++ active wrap
	0 * . = (0 * .) * (s(0) * .)
... with sequence
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	0 * . = (0 * .) * (s(0) * .)
+++ Presburger system  = {
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
+++ }
+++ Lemma(s)           = 
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
--- clause
	0 * (0 * (0 * (0 * power(0, xts)))) = (0 * (0 * (0 * (0 * power(0, xts))))) * (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))))
... subsumed by lemma
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))

+++ treating clause
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
+++ inductive narrowing on conjecture
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
... induction variables of
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
... with variable xts
+++ creating new conjecture
	s(0) * (s(0) * power(s(0), 1)) = (s(0) * (s(0) * power(s(0), 1))) * (s(0) * (s(0) * power(s(0), 1)))
+++ creating new conjecture
	s(0) * (s(0) * power(s(0), sexp(xts))) = (s(0) * (s(0) * power(s(0), sexp(xts)))) * (s(0) * (s(0) * power(s(0), sexp(xts))))
--- clause
	s(0) * (s(0) * power(s(0), 1)) = (s(0) * (s(0) * power(s(0), 1))) * (s(0) * (s(0) * power(s(0), 1)))
... reduced to tautology
	s(0) = s(0)
--- clause
	s(0) * (s(0) * power(s(0), sexp(xts))) = (s(0) * (s(0) * power(s(0), sexp(xts)))) * (s(0) * (s(0) * power(s(0), sexp(xts))))
... reduced in 3 steps to
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
+++ inductive narrowing succeeded
--- clause
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
... oriented to rule
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
+++ added new clause(s)
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))

+++ treating clause
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
+++ inductive narrowing on conjecture
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
... induction variables of
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
... with variable xts
+++ creating new conjecture
	s(s(0)) * power(s(s(0)), 1) = (s(s(0)) * power(s(s(0)), 1)) * (s(0) * power(s(0), 1))
+++ creating new conjecture
	s(s(0)) * power(s(s(0)), sexp(xts)) = (s(s(0)) * power(s(s(0)), sexp(xts))) * (s(0) * power(s(0), sexp(xts)))
--- clause
	s(s(0)) * power(s(s(0)), 1) = (s(s(0)) * power(s(s(0)), 1)) * (s(0) * power(s(0), 1))
... reduced to tautology
	s(s(s(s(0)))) = s(s(s(s(0))))
--- clause
	s(s(0)) * power(s(s(0)), sexp(xts)) = (s(s(0)) * power(s(s(0)), sexp(xts))) * (s(0) * power(s(0), sexp(xts)))
... reduced in 3 steps to
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
+++ inductive narrowing succeeded
--- clause
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
... oriented to rule
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
+++ added new clause(s)
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
... to conjectures
+++ active wrap
	. * power(., xts) = (. * power(., xts)) * (s(0) * power(s(0), xts))
... with sequence
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	. * power(., xts) = (. * power(., xts)) * (s(0) * power(s(0), xts))
+++ Presburger system  = {
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))

+++ Status of the Inference System
--- Conjectures:
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))

+++ treating clause
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
+++ inductive narrowing on conjecture
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... induction variables of
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... with variable xts
+++ creating new conjecture
	0 * (0 * power(0, 1)) = (0 * (0 * power(0, 1))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))
+++ creating new conjecture
	0 * (0 * power(0, sexp(xts))) = (0 * (0 * power(0, sexp(xts)))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))
--- clause
	0 * (0 * power(0, 1)) = (0 * (0 * power(0, 1))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))
... reduced to tautology
	0 = 0
--- clause
	0 * (0 * power(0, sexp(xts))) = (0 * (0 * power(0, sexp(xts)))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))
... reduced in 3 steps to
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
+++ inductive narrowing succeeded
--- clause
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... oriented to rule
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
+++ added new clause(s)
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))

+++ treating clause
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
+++ inductive narrowing on conjecture
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
... induction variables of
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
... with variable xts
+++ creating new conjecture
	s(s(0)) * power(s(s(0)), 1) = (s(0) * power(s(0), 1)) * (s(s(0)) * power(s(s(0)), 1))
+++ creating new conjecture
	s(s(0)) * power(s(s(0)), sexp(xts)) = (s(0) * power(s(0), sexp(xts))) * (s(s(0)) * power(s(s(0)), sexp(xts)))
--- clause
	s(s(0)) * power(s(s(0)), 1) = (s(0) * power(s(0), 1)) * (s(s(0)) * power(s(s(0)), 1))
... reduced to tautology
	s(s(s(s(0)))) = s(s(s(s(0))))
--- clause
	s(s(0)) * power(s(s(0)), sexp(xts)) = (s(0) * power(s(0), sexp(xts))) * (s(s(0)) * power(s(s(0)), sexp(xts)))
... reduced in 3 steps to
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
+++ inductive narrowing succeeded
--- clause
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
... oriented to rule
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
+++ added new clause(s)
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))

+++ treating clause
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
+++ inductive narrowing on conjecture
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
... induction variables of
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
... are:
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
... with variable ze
+++ creating new conjecture
	power(s(s(s(s(0)))), 1) = power(s(s(0)), 1) * power(s(s(0)), 1)
+++ creating new conjecture
	power(s(s(s(s(0)))), sexp(xts)) = power(s(s(0)), sexp(xts)) * power(s(s(0)), sexp(xts))
--- clause
	power(s(s(s(s(0)))), 1) = power(s(s(0)), 1) * power(s(s(0)), 1)
... reduced to tautology
	s(s(s(s(0)))) = s(s(s(s(0))))
--- clause
	power(s(s(s(s(0)))), sexp(xts)) = power(s(s(0)), sexp(xts)) * power(s(s(0)), sexp(xts))
... reduced in 3 steps to
	s(s(s(s(0)))) * power(s(s(s(s(0)))), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
+++ inductive narrowing succeeded
--- clause
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
... oriented to rule
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
+++ added new clause(s)
	s(s(s(s(0)))) * power(s(s(s(s(0)))), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
... to conjectures
--- clause
	s(s(s(s(0)))) * power(s(s(s(s(0)))), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
... reduced in 1 step to
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
+++ active wrap
	power(., ze) = power(., ze) * power(s(s(0)), ze)
... with sequence
	power(0, ze) = power(0, ze) * power(s(s(0)), ze)
	power(s(s(0)), ze) = power(s(0), ze) * power(s(s(0)), ze)
	power(s(s(s(s(0)))), ze) = power(s(s(0)), ze) * power(s(s(0)), ze)
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	power(., ze) = power(., ze) * power(s(s(0)), ze)
+++ Presburger system  = {
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)

+++ Status of the Inference System
--- Conjectures:
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)

+++ treating clause
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
+++ inductive narrowing on conjecture
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
... induction variables of
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
... with variable xts
+++ creating new conjecture
	power(s(s(s(s(s(s(0 + 0))) + 0))), ze) = power(s(s(s(0))), ze) * power(s(s(0)), ze)
+++ creating new conjecture
	power(s(s(s(s(s(s(0 + s(xts)))) + s(xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(s(0)), ze)
--- clause
	power(s(s(s(s(s(s(0 + 0))) + 0))), ze) = power(s(s(s(0))), ze) * power(s(s(0)), ze)
... reduced in 2 steps to
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(s(0))), ze) * power(s(s(0)), ze)
--- clause
	power(s(s(s(s(s(s(0 + s(xts)))) + s(xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(s(0)), ze)
... reduced in 2 steps to
	power(s(s(s(s(s(s(s(s(0 + xts)))) + xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(s(0)), ze)
--- clause
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(s(0))), ze) * power(s(s(0)), ze)
... subsumed by lemma
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
... with substitution
	$n <- 3
+++ inductive narrowing succeeded
--- clause
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
... oriented to rule
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
+++ added new clause(s)
	power(s(s(s(s(s(s(s(s(0 + xts)))) + xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(s(0)), ze)
... to conjectures
+++ active wrap
	power(., ze) = power(., ze) * power(s(s(0)), ze)
... with sequence
	power(s(s(0 + xts) + xts), ze) = power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(s(0 + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(0)), ze)
+++ primal grammar found for head
	{*, +, 0, power, s}
... and wrap
	power(., ze) = power(., ze) * power(s(s(0)), ze)
+++ Presburger system  = {
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
--- clause
	power(s(s(s(s(s(s(s(s(0 + xts)))) + xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(s(0)), ze)
... subsumed by lemma
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)

+++ treating clause
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
+++ inductive narrowing on conjecture
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... induction variables of
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... with variable xts
+++ creating new conjecture
	0 * power(0, 1) = (0 * power(0, 1)) * (s(s(s(0))) * power(s(s(s(0))), 1))
+++ creating new conjecture
	0 * power(0, sexp(xts)) = (0 * power(0, sexp(xts))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))
--- clause
	0 * power(0, 1) = (0 * power(0, 1)) * (s(s(s(0))) * power(s(s(s(0))), 1))
... reduced to tautology
	0 = 0
--- clause
	0 * power(0, sexp(xts)) = (0 * power(0, sexp(xts))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))
... reduced in 3 steps to
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
+++ inductive narrowing succeeded
--- clause
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... oriented to rule
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
+++ added new clause(s)
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... to conjectures
+++ active wrap
	0 * power(0, xts) = (0 * power(0, xts)) * (s(.) * power(s(.), xts))
... with sequence
	0 * power(0, xts) = (0 * power(0, xts)) * (s(0) * power(s(0), xts))
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	0 * power(0, xts) = (0 * power(0, xts)) * (s(.) * power(s(.), xts))
+++ Presburger system  = {
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))

+++ Status of the Inference System
--- Conjectures:
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))

+++ treating clause
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
+++ inductive narrowing on conjecture
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
... induction variables of
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
... are:
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
... with variable ze
+++ creating new conjecture
	power(s(s(s(0))), 1) = power(s(0), 1) * power(s(s(s(0))), 1)
+++ creating new conjecture
	power(s(s(s(0))), sexp(xts)) = power(s(0), sexp(xts)) * power(s(s(s(0))), sexp(xts))
--- clause
	power(s(s(s(0))), 1) = power(s(0), 1) * power(s(s(s(0))), 1)
... reduced to tautology
	s(s(s(0))) = s(s(s(0)))
--- clause
	power(s(s(s(0))), sexp(xts)) = power(s(0), sexp(xts)) * power(s(s(s(0))), sexp(xts))
... reduced in 3 steps to
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
+++ inductive narrowing succeeded
--- clause
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
... oriented to rule
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
+++ added new clause(s)
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))

+++ treating clause
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
+++ inductive narrowing on conjecture
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
... induction variables of
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
... with variable xts
+++ creating new conjecture
	power(s(s(s(s(s(s(0 + 0)) + 0)) + 0)), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
+++ creating new conjecture
	power(s(s(s(s(s(s(0 + s(xts))) + s(xts))) + s(xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
--- clause
	power(s(s(s(s(s(s(0 + 0)) + 0)) + 0)), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
... reduced in 3 steps to
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
--- clause
	power(s(s(s(s(s(s(0 + s(xts))) + s(xts))) + s(xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
... reduced in 3 steps to
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
+++ inductive narrowing succeeded
--- clause
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
... oriented to rule
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
+++ added new clause(s)
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))

+++ treating clause
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
+++ inductive narrowing on conjecture
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... induction variables of
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... with variable xts
+++ creating new conjecture
	s(0) * (s(0) * (s(0) * power(s(0), 1))) = (s(0) * (s(0) * (s(0) * power(s(0), 1)))) * (s(0) * (s(0) * (s(0) * power(s(0), 1))))
+++ creating new conjecture
	s(0) * (s(0) * (s(0) * power(s(0), sexp(xts)))) = (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts))))) * (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts)))))
--- clause
	s(0) * (s(0) * (s(0) * power(s(0), 1))) = (s(0) * (s(0) * (s(0) * power(s(0), 1)))) * (s(0) * (s(0) * (s(0) * power(s(0), 1))))
... reduced to tautology
	s(0) = s(0)
--- clause
	s(0) * (s(0) * (s(0) * power(s(0), sexp(xts)))) = (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts))))) * (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts)))))
... reduced in 3 steps to
	s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) = (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))) * (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))))
+++ inductive narrowing succeeded
--- clause
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... oriented to rule
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
+++ added new clause(s)
	s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) = (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))) * (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))))
... to conjectures
+++ active wrap
	s(0) * . = (s(0) * .) * (s(0) * .)
... with sequence
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
	s(0) * (s(0) * power(s(0), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(0) * (s(0) * (s(0) * power(s(0), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	s(0) * . = (s(0) * .) * (s(0) * .)
+++ Presburger system  = {
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
+++ }
+++ Lemma(s)           = 
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
--- clause
	s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) = (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))) * (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))))
... subsumed by lemma
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))

+++ treating clause
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
+++ inductive narrowing on conjecture
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
... induction variables of
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
... with variable xts
+++ creating new conjecture
	s(s(0)) * (s(s(0)) * power(s(s(0)), 1)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) * (s(0) * (s(0) * power(s(0), 1)))
+++ creating new conjecture
	s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) * (s(0) * (s(0) * power(s(0), sexp(xts))))
--- clause
	s(s(0)) * (s(s(0)) * power(s(s(0)), 1)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) * (s(0) * (s(0) * power(s(0), 1)))
... reduced to tautology
	s(s(s(s(s(s(s(s(0)))))))) = s(s(s(s(s(s(s(s(0))))))))
--- clause
	s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) * (s(0) * (s(0) * power(s(0), sexp(xts))))
... reduced in 3 steps to
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
+++ inductive narrowing succeeded
--- clause
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
... oriented to rule
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
+++ added new clause(s)
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))

+++ treating clause
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
+++ inductive narrowing on conjecture
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... induction variables of
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... with variable xts
+++ creating new conjecture
	0 * (0 * (0 * power(0, 1))) = (0 * (0 * (0 * power(0, 1)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))))
+++ creating new conjecture
	0 * (0 * (0 * power(0, sexp(xts)))) = (0 * (0 * (0 * power(0, sexp(xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))))
--- clause
	0 * (0 * (0 * power(0, 1))) = (0 * (0 * (0 * power(0, 1)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))))
... reduced to tautology
	0 = 0
--- clause
	0 * (0 * (0 * power(0, sexp(xts)))) = (0 * (0 * (0 * power(0, sexp(xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))))
... reduced in 3 steps to
	0 * (0 * (0 * (0 * power(0, xts)))) = (0 * (0 * (0 * (0 * power(0, xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))))
+++ inductive narrowing succeeded
--- clause
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... oriented to rule
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
+++ added new clause(s)
	0 * (0 * (0 * (0 * power(0, xts)))) = (0 * (0 * (0 * (0 * power(0, xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))))
... to conjectures
+++ active wrap
	0 * . = (0 * .) * (s(s(0)) * .)
... with sequence
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	0 * . = (0 * .) * (s(s(0)) * .)
+++ Presburger system  = {
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
+++ }
+++ Lemma(s)           = 
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
--- clause
	0 * (0 * (0 * (0 * power(0, xts)))) = (0 * (0 * (0 * (0 * power(0, xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))))
... subsumed by lemma
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))

+++ treating clause
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
+++ inductive narrowing on conjecture
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... induction variables of
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... with variable xts
+++ creating new conjecture
	s(s(0)) * (s(s(0)) * power(s(s(0)), 1)) = (s(0) * (s(0) * power(s(0), 1))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))
+++ creating new conjecture
	s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))) = (s(0) * (s(0) * power(s(0), sexp(xts)))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))
--- clause
	s(s(0)) * (s(s(0)) * power(s(s(0)), 1)) = (s(0) * (s(0) * power(s(0), 1))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))
... reduced to tautology
	s(s(s(s(s(s(s(s(0)))))))) = s(s(s(s(s(s(s(s(0))))))))
--- clause
	s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))) = (s(0) * (s(0) * power(s(0), sexp(xts)))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))
... reduced in 3 steps to
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
+++ inductive narrowing succeeded
--- clause
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... oriented to rule
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
+++ added new clause(s)
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))

+++ treating clause
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
+++ inductive narrowing on conjecture
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
... induction variables of
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
... with variable xts
+++ creating new conjecture
	s(s(s(s(0)))) * (power(s(s(0)), 1) * power(s(s(0)), 1)) = (s(s(0)) * power(s(s(0)), 1)) * (s(s(0)) * power(s(s(0)), 1))
+++ creating new conjecture
	s(s(s(s(0)))) * (power(s(s(0)), sexp(xts)) * power(s(s(0)), sexp(xts))) = (s(s(0)) * power(s(s(0)), sexp(xts))) * (s(s(0)) * power(s(s(0)), sexp(xts)))
--- clause
	s(s(s(s(0)))) * (power(s(s(0)), 1) * power(s(s(0)), 1)) = (s(s(0)) * power(s(s(0)), 1)) * (s(s(0)) * power(s(s(0)), 1))
... reduced to tautology
	s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))) = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))
--- clause
	s(s(s(s(0)))) * (power(s(s(0)), sexp(xts)) * power(s(s(0)), sexp(xts))) = (s(s(0)) * power(s(s(0)), sexp(xts))) * (s(s(0)) * power(s(s(0)), sexp(xts)))
... reduced in 4 steps to
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
+++ inductive narrowing succeeded
--- clause
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
... oriented to rule
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
+++ added new clause(s)
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))

+++ treating clause
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
+++ inductive narrowing on conjecture
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... induction variables of
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... with variable xts
+++ creating new conjecture
	0 * (0 * power(0, 1)) = (0 * (0 * power(0, 1))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1)))
+++ creating new conjecture
	0 * (0 * power(0, sexp(xts))) = (0 * (0 * power(0, sexp(xts)))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts))))
--- clause
	0 * (0 * power(0, 1)) = (0 * (0 * power(0, 1))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1)))
... reduced to tautology
	0 = 0
--- clause
	0 * (0 * power(0, sexp(xts))) = (0 * (0 * power(0, sexp(xts)))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts))))
... reduced in 3 steps to
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
+++ inductive narrowing succeeded
--- clause
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... oriented to rule
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
+++ added new clause(s)
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))

+++ treating clause
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
+++ inductive narrowing on conjecture
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... induction variables of
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... with variable xts
+++ creating new conjecture
	s(s(s(0))) * power(s(s(s(0))), 1) = (s(0) * power(s(0), 1)) * (s(s(s(0))) * power(s(s(s(0))), 1))
+++ creating new conjecture
	s(s(s(0))) * power(s(s(s(0))), sexp(xts)) = (s(0) * power(s(0), sexp(xts))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))
--- clause
	s(s(s(0))) * power(s(s(s(0))), 1) = (s(0) * power(s(0), 1)) * (s(s(s(0))) * power(s(s(s(0))), 1))
... reduced to tautology
	s(s(s(s(s(s(s(s(s(0))))))))) = s(s(s(s(s(s(s(s(s(0)))))))))
--- clause
	s(s(s(0))) * power(s(s(s(0))), sexp(xts)) = (s(0) * power(s(0), sexp(xts))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))
... reduced in 3 steps to
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
+++ inductive narrowing succeeded
--- clause
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... oriented to rule
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
+++ added new clause(s)
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... to conjectures
+++ active wrap
	s(.) * power(s(.), xts) = (s(0) * power(s(0), xts)) * (s(.) * power(s(.), xts))
... with sequence
	s(0) * power(s(0), xts) = (s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts))
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	s(.) * power(s(.), xts) = (s(0) * power(s(0), xts)) * (s(.) * power(s(.), xts))
+++ Presburger system  = {
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))

+++ Status of the Inference System
--- Conjectures:
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))

+++ treating clause
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
+++ inductive narrowing on conjecture
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
... induction variables of
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
... are:
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
... with variable ze
+++ creating new conjecture
	power(s(s(s(s(s(s(0)))))), 1) = power(s(s(0)), 1) * power(s(s(s(0))), 1)
+++ creating new conjecture
	power(s(s(s(s(s(s(0)))))), sexp(xts)) = power(s(s(0)), sexp(xts)) * power(s(s(s(0))), sexp(xts))
--- clause
	power(s(s(s(s(s(s(0)))))), 1) = power(s(s(0)), 1) * power(s(s(s(0))), 1)
... reduced to tautology
	s(s(s(s(s(s(0)))))) = s(s(s(s(s(s(0))))))
--- clause
	power(s(s(s(s(s(s(0)))))), sexp(xts)) = power(s(s(0)), sexp(xts)) * power(s(s(s(0))), sexp(xts))
... reduced in 3 steps to
	s(s(s(s(s(s(0)))))) * power(s(s(s(s(s(s(0)))))), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
+++ inductive narrowing succeeded
--- clause
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
... oriented to rule
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
+++ added new clause(s)
	s(s(s(s(s(s(0)))))) * power(s(s(s(s(s(s(0)))))), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... to conjectures
--- clause
	s(s(s(s(s(s(0)))))) * power(s(s(s(s(s(s(0)))))), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... reduced in 1 step to
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
+++ active wrap
	power(., ze) = power(., ze) * power(s(s(s(0))), ze)
... with sequence
	power(0, ze) = power(0, ze) * power(s(s(s(0))), ze)
	power(s(s(s(0))), ze) = power(s(0), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0)))))), ze) = power(s(s(0)), ze) * power(s(s(s(0))), ze)
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	power(., ze) = power(., ze) * power(s(s(s(0))), ze)
+++ Presburger system  = {
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
+++ }
+++ Lemma(s)           = 
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)

+++ Status of the Inference System
--- Conjectures:
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)

+++ treating clause
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
+++ inductive narrowing on conjecture
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
... induction variables of
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
... are:
	xts:nat
	ze:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
... with variable xts
+++ creating new conjecture
	power(s(s(s(s(s(s(s(s(s(0 + 0))) + 0))) + 0))), ze) = power(s(s(s(0))), ze) * power(s(s(s(0))), ze)
+++ creating new conjecture
	power(s(s(s(s(s(s(s(s(s(0 + s(xts)))) + s(xts)))) + s(xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(s(s(0))), ze)
--- clause
	power(s(s(s(s(s(s(s(s(s(0 + 0))) + 0))) + 0))), ze) = power(s(s(s(0))), ze) * power(s(s(s(0))), ze)
... reduced in 3 steps to
	power(s(s(s(s(s(s(s(s(s(0))))))))), ze) = power(s(s(s(0))), ze) * power(s(s(s(0))), ze)
--- clause
	power(s(s(s(s(s(s(s(s(s(0 + s(xts)))) + s(xts)))) + s(xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(s(s(0))), ze)
... reduced in 3 steps to
	power(s(s(s(s(s(s(s(s(s(s(s(s(0 + xts)))) + xts)))) + xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(s(s(0))), ze)
--- clause
	power(s(s(s(s(s(s(s(s(s(0))))))))), ze) = power(s(s(s(0))), ze) * power(s(s(s(0))), ze)
... subsumed by lemma
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
... with substitution
	$n <- 3
+++ inductive narrowing succeeded
--- clause
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
... oriented to rule
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
+++ added new clause(s)
	power(s(s(s(s(s(s(s(s(s(s(s(s(0 + xts)))) + xts)))) + xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(s(s(0))), ze)
... to conjectures
+++ active wrap
	power(., ze) = power(., ze) * power(s(s(s(0))), ze)
... with sequence
	power(s(s(s(0 + xts) + xts) + xts), ze) = power(s(xts), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) = power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) = power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
+++ primal grammar found for head
	{*, +, 0, power, s}
... and wrap
	power(., ze) = power(., ze) * power(s(s(s(0))), ze)
+++ Presburger system  = {
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
--- clause
	power(s(s(s(s(s(s(s(s(s(s(s(s(0 + xts)))) + xts)))) + xts)))), ze) = power(s(s(s(s(xts)))), ze) * power(s(s(s(0))), ze)
... subsumed by lemma
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)

+++ treating clause
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
+++ inductive narrowing on conjecture
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... induction variables of
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... with variable xts
+++ creating new conjecture
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))) * (s(0) * (s(0) * (s(0) * power(s(0), 1))))
+++ creating new conjecture
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))) * (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts)))))
--- clause
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))) * (s(0) * (s(0) * (s(0) * power(s(0), 1))))
... reduced to tautology
	s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))) = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))
--- clause
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))) * (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts)))))
... reduced in 3 steps to
	s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) * (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))))
+++ inductive narrowing succeeded
--- clause
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
... oriented to rule
	(s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
+++ added new clause(s)
	s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) * (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))))
... to conjectures
+++ active wrap
	s(s(0)) * . = (s(s(0)) * .) * (s(0) * .)
... with sequence
	s(s(0)) * power(s(s(0)), xts) = (s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts)))
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	s(s(0)) * . = (s(s(0)) * .) * (s(0) * .)
+++ Presburger system  = {
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
+++ }
+++ Lemma(s)           = 
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))
--- clause
	s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) * (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))))
... subsumed by lemma
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
	(s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))

+++ treating clause
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
+++ inductive narrowing on conjecture
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... induction variables of
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... with variable xts
+++ creating new conjecture
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) = (s(0) * (s(0) * (s(0) * power(s(0), 1)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))))
+++ creating new conjecture
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) = (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))))
--- clause
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) = (s(0) * (s(0) * (s(0) * power(s(0), 1)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))))
... reduced to tautology
	s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))) = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))
--- clause
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) = (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))))
... reduced in 3 steps to
	s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))))
+++ inductive narrowing succeeded
--- clause
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... oriented to rule
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
+++ added new clause(s)
	s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))))
... to conjectures
+++ active wrap
	s(s(0)) * . = (s(0) * .) * (s(s(0)) * .)
... with sequence
	s(s(0)) * power(s(s(0)), xts) = (s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(0)) * (s(s(0)) * power(s(s(0)), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	s(s(0)) * . = (s(0) * .) * (s(s(0)) * .)
+++ Presburger system  = {
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
+++ }
+++ Lemma(s)           = 
	s(s(0)) * ^f20($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(0)) * ^f20($n; xts))
--- clause
	s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))))
... subsumed by lemma
	s(s(0)) * ^f20($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(0)) * ^f20($n; xts))
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))
	s(s(0)) * ^f20($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(0)) * ^f20($n; xts))

+++ treating clause
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
+++ inductive narrowing on conjecture
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... induction variables of
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... with variable xts
+++ creating new conjecture
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), 1)) * (s(s(0)) * power(s(s(0)), 1))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))
+++ creating new conjecture
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), sexp(xts))) * (s(s(0)) * power(s(s(0)), sexp(xts)))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))
--- clause
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), 1)) * (s(s(0)) * power(s(s(0)), 1))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))
... reduced to tautology
	s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
--- clause
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), sexp(xts))) * (s(s(0)) * power(s(s(0)), sexp(xts)))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))
... reduced in 4 steps to
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
+++ inductive narrowing succeeded
--- clause
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
... oriented to rule
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
+++ added new clause(s)
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))
	s(s(0)) * ^f20($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(0)) * ^f20($n; xts))

+++ treating clause
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
+++ inductive narrowing on conjecture
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... induction variables of
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... with variable xts
+++ creating new conjecture
	0 * (0 * (0 * power(0, 1))) = (0 * (0 * (0 * power(0, 1)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1))))
+++ creating new conjecture
	0 * (0 * (0 * power(0, sexp(xts)))) = (0 * (0 * (0 * power(0, sexp(xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))))
--- clause
	0 * (0 * (0 * power(0, 1))) = (0 * (0 * (0 * power(0, 1)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1))))
... reduced to tautology
	0 = 0
--- clause
	0 * (0 * (0 * power(0, sexp(xts)))) = (0 * (0 * (0 * power(0, sexp(xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))))
... reduced in 3 steps to
	0 * (0 * (0 * (0 * power(0, xts)))) = (0 * (0 * (0 * (0 * power(0, xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))))
+++ inductive narrowing succeeded
--- clause
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... oriented to rule
	(0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> 0 * (0 * (0 * power(0, xts)))
+++ added new clause(s)
	0 * (0 * (0 * (0 * power(0, xts)))) = (0 * (0 * (0 * (0 * power(0, xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))))
... to conjectures
+++ active wrap
	0 * . = (0 * .) * (s(s(s(0))) * .)
... with sequence
	0 * power(0, xts) = (0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	0 * (0 * power(0, xts)) = (0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	0 * (0 * (0 * power(0, xts))) = (0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	0 * . = (0 * .) * (s(s(s(0))) * .)
+++ Presburger system  = {
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f29(0; xts) -> power(s(s(s(0))), xts)
	^f29($n29 + 1; xts) -> s(s(s(0))) * ^f29($n29; xts)
+++ }
+++ Lemma(s)           = 
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(s(0))) * ^f29($n; xts))
--- clause
	0 * (0 * (0 * (0 * power(0, xts)))) = (0 * (0 * (0 * (0 * power(0, xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))))
... subsumed by lemma
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(s(0))) * ^f29($n; xts))
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f29(0; xts) -> power(s(s(s(0))), xts)
	^f29($n29 + 1; xts) -> s(s(s(0))) * ^f29($n29; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))
	s(s(0)) * ^f20($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(0)) * ^f20($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(s(0))) * ^f29($n; xts))

+++ treating clause
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
+++ inductive narrowing on conjecture
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... induction variables of
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... with variable xts
+++ creating new conjecture
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1)) = (s(0) * (s(0) * power(s(0), 1))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1)))
+++ creating new conjecture
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts))) = (s(0) * (s(0) * power(s(0), sexp(xts)))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts))))
--- clause
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1)) = (s(0) * (s(0) * power(s(0), 1))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1)))
... reduced to tautology
	s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))))))))))))) = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))))))))
--- clause
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts))) = (s(0) * (s(0) * power(s(0), sexp(xts)))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts))))
... reduced in 3 steps to
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
+++ inductive narrowing succeeded
--- clause
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... oriented to rule
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))
+++ added new clause(s)
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f29(0; xts) -> power(s(s(s(0))), xts)
	^f29($n29 + 1; xts) -> s(s(s(0))) * ^f29($n29; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))
	s(s(0)) * ^f20($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(0)) * ^f20($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(s(0))) * ^f29($n; xts))

+++ treating clause
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
+++ inductive narrowing on conjecture
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... induction variables of
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... with variable xts
+++ creating new conjecture
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), 1) * power(s(s(s(0))), 1)) = (s(s(0)) * power(s(s(0)), 1)) * (s(s(s(0))) * power(s(s(s(0))), 1))
+++ creating new conjecture
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), sexp(xts)) * power(s(s(s(0))), sexp(xts))) = (s(s(0)) * power(s(s(0)), sexp(xts))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))
--- clause
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), 1) * power(s(s(s(0))), 1)) = (s(s(0)) * power(s(s(0)), 1)) * (s(s(s(0))) * power(s(s(s(0))), 1))
... reduced to tautology
	s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))))))))))))))))) = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))))))))))))))))))))))
--- clause
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), sexp(xts)) * power(s(s(s(0))), sexp(xts))) = (s(s(0)) * power(s(s(0)), sexp(xts))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))
... reduced in 4 steps to
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
+++ inductive narrowing succeeded
--- clause
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
... oriented to rule
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
+++ added new clause(s)
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f29(0; xts) -> power(s(s(s(0))), xts)
	^f29($n29 + 1; xts) -> s(s(s(0))) * ^f29($n29; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))
	s(s(0)) * ^f20($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(0)) * ^f20($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(s(0))) * ^f29($n; xts))

+++ treating clause
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
+++ inductive narrowing on conjecture
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... induction variables of
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... with variable xts
+++ creating new conjecture
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))))
+++ creating new conjecture
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))))
--- clause
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))))
... reduced to tautology
	s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
--- clause
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))))
... reduced in 4 steps to
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))))
+++ inductive narrowing succeeded
--- clause
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
... oriented to rule
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
+++ added new clause(s)
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))))
... to conjectures
+++ active wrap
	s(s(s(s(0)))) * (. * .) = (s(s(0)) * .) * (s(s(0)) * .)
... with sequence
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	s(s(s(s(0)))) * (. * .) = (s(s(0)) * .) * (s(s(0)) * .)
+++ Presburger system  = {
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
+++ }
+++ Lemma(s)           = 
	s(s(s(s(0)))) * (^f20($n; xts) * ^f20($n; xts)) = (s(s(0)) * ^f20($n; xts)) * (s(s(0)) * ^f20($n; xts))
--- clause
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))))
... subsumed by lemma
	s(s(s(s(0)))) * (^f20($n; xts) * ^f20($n; xts)) = (s(s(0)) * ^f20($n; xts)) * (s(s(0)) * ^f20($n; xts))
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f29(0; xts) -> power(s(s(s(0))), xts)
	^f29($n29 + 1; xts) -> s(s(s(0))) * ^f29($n29; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))
	s(s(0)) * ^f20($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(0)) * ^f20($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(s(0))) * ^f29($n; xts))
	s(s(s(s(0)))) * (^f20($n; xts) * ^f20($n; xts)) = (s(s(0)) * ^f20($n; xts)) * (s(s(0)) * ^f20($n; xts))

+++ treating clause
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
+++ inductive narrowing on conjecture
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... induction variables of
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... with variable xts
+++ creating new conjecture
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1))) = (s(0) * (s(0) * (s(0) * power(s(0), 1)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1))))
+++ creating new conjecture
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))) = (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))))
--- clause
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1))) = (s(0) * (s(0) * (s(0) * power(s(0), 1)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1))))
... reduced to tautology
	s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
--- clause
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))) = (s(0) * (s(0) * (s(0) * power(s(0), sexp(xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))))
... reduced in 3 steps to
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))))
+++ inductive narrowing succeeded
--- clause
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... oriented to rule
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
+++ added new clause(s)
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))))
... to conjectures
+++ active wrap
	s(s(s(0))) * . = (s(0) * .) * (s(s(s(0))) * .)
... with sequence
	s(s(s(0))) * power(s(s(s(0))), xts) = (s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)) = (s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	s(s(s(0))) * . = (s(0) * .) * (s(s(s(0))) * .)
+++ Presburger system  = {
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f29(0; xts) -> power(s(s(s(0))), xts)
	^f29($n29 + 1; xts) -> s(s(s(0))) * ^f29($n29; xts)
+++ }
+++ Lemma(s)           = 
	s(s(s(0))) * ^f29($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(s(0))) * ^f29($n; xts))
--- clause
	s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(0) * (s(0) * (s(0) * (s(0) * power(s(0), xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))))
... subsumed by lemma
	s(s(s(0))) * ^f29($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(s(0))) * ^f29($n; xts))
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f29(0; xts) -> power(s(s(s(0))), xts)
	^f29($n29 + 1; xts) -> s(s(s(0))) * ^f29($n29; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))
	s(s(0)) * ^f20($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(0)) * ^f20($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(s(0))) * ^f29($n; xts))
	s(s(s(s(0)))) * (^f20($n; xts) * ^f20($n; xts)) = (s(s(0)) * ^f20($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(s(s(0))) * ^f29($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(s(0))) * ^f29($n; xts))

+++ treating clause
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
+++ inductive narrowing on conjecture
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... induction variables of
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... with variable xts
+++ creating new conjecture
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), 1)) * (s(s(s(0))) * power(s(s(s(0))), 1))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1)))
+++ creating new conjecture
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), sexp(xts))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts))))
--- clause
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), 1)) * (s(s(s(0))) * power(s(s(s(0))), 1))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1)))
... reduced to tautology
	s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
--- clause
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), sexp(xts))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts))))
... reduced in 4 steps to
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
+++ inductive narrowing succeeded
--- clause
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
... oriented to rule
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
+++ added new clause(s)
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... to conjectures

+++ Status of the Inference System
--- Conjectures:
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f29(0; xts) -> power(s(s(s(0))), xts)
	^f29($n29 + 1; xts) -> s(s(s(0))) * ^f29($n29; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))
	s(s(0)) * ^f20($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(0)) * ^f20($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(s(0))) * ^f29($n; xts))
	s(s(s(s(0)))) * (^f20($n; xts) * ^f20($n; xts)) = (s(s(0)) * ^f20($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(s(s(0))) * ^f29($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(s(0))) * ^f29($n; xts))

+++ treating clause
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
+++ inductive narrowing on conjecture
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... induction variables of
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... are:
	xts:exp
+++ perform INDUCTIVE NARROWING on conjecture 
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... with variable xts
+++ creating new conjecture
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1))))
+++ creating new conjecture
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts))))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))))
--- clause
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), 1))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), 1)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), 1))))
... reduced to tautology
	s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
--- clause
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts)))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts))))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), sexp(xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), sexp(xts)))))
... reduced in 4 steps to
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))))
+++ inductive narrowing succeeded
--- clause
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
... oriented to rule
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
+++ added new clause(s)
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))))
... to conjectures
+++ active wrap
	s(s(s(s(s(s(0)))))) * (. * .) = (s(s(0)) * .) * (s(s(s(0))) * .)
... with sequence
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) = (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) = (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
+++ primal grammar found for head
	{*, 0, power, s}
... and wrap
	s(s(s(s(s(s(0)))))) * (. * .) = (s(s(0)) * .) * (s(s(s(0))) * .)
+++ Presburger system  = {
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f29(0; xts) -> power(s(s(s(0))), xts)
	^f29($n29 + 1; xts) -> s(s(s(0))) * ^f29($n29; xts)
+++ }
+++ Lemma(s)           = 
	s(s(s(s(s(s(0)))))) * (^f20($n; xts) * ^f29($n; xts)) = (s(s(0)) * ^f20($n; xts)) * (s(s(s(0))) * ^f29($n; xts))
--- clause
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))) = (s(s(0)) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))))
... subsumed by lemma
	s(s(s(s(s(s(0)))))) * (^f20($n; xts) * ^f29($n; xts)) = (s(s(0)) * ^f20($n; xts)) * (s(s(s(0))) * ^f29($n; xts))
... with substitution
	$n <- 3

+++ Status of the Inference System
--- Conjectures:
	<empty>
--- Non-orientable hypotheses:
	<empty>
--- Oriented hypotheses:
	power(x, ze) * power(0, ze) -> power(0, ze)
	power(0, ze) * power(s(0), ze) -> power(0, ze)
	power(x * y, ze) -> power(x, ze) * power(y, ze)
	power(0, ze) * power(s(s(0)), ze) -> power(0, ze)
	power(0 + x, ze) -> power(x, ze) * power(s(0), ze)
	power(0, ze) * power(s(s(s(0))), ze) -> power(0, ze)
	power(s(0), ze) * power(s(0), ze) -> power(s(0), ze)
	power(s(0), ze) * power(s(s(0)), ze) -> power(s(s(0)), ze)
	power(s(s(0)), ze) * power(s(0), ze) -> power(s(s(0)), ze)
	power((0 + x) + x, ze) -> power(x, ze) * power(s(s(0)), ze)
	power((x * xts) + x, ze) -> power(x, ze) * power(s(xts), ze)
	power(s(0 + xts), ze) -> power(s(xts), ze) * power(s(0), ze)
	(x * power(x, xts)) * (0 * power(0, xts)) -> 0 * power(0, xts)
	power(s(0), ze) * power(s(s(s(0))), ze) -> power(s(s(s(0))), ze)
	power(s(s(0 + xts)), ze) -> power(s(s(xts)), ze) * power(s(0), ze)
	power(s(s(s(s(0)))), ze) -> power(s(s(0)), ze) * power(s(s(0)), ze)
	(0 * power(0, xts)) * (s(0) * power(s(0), xts)) -> 0 * power(0, xts)
	power(((0 + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(0))), ze)
	power(((x * xts) + x) + x, ze) -> power(x, ze) * power(s(s(xts)), ze)
	power(s(s(0 + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(0), ze)
	(0 * power(0, xts)) * (s(s(0)) * power(s(s(0)), xts)) -> 0 * power(0, xts)
	power(s(s(s(s(s(s(0)))))), ze) -> power(s(s(0)), ze) * power(s(s(s(0))), ze)
	power((((x * xts) + x) + x) + x, ze) -> power(x, ze) * power(s(s(s(xts))), ze)
	(0 * power(0, xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> 0 * power(0, xts)
	(s(0) * power(s(0), xts)) * (s(0) * power(s(0), xts)) -> s(0) * power(s(0), xts)
	(x * (x * power(x, xts))) * (0 * (0 * power(0, xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(0 + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(0)), ze)
	power(s(s(s(0 + xts) + xts) + xts), ze) -> power(s(xts), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(0) * (s(0) * power(s(0), xts))) -> 0 * (0 * power(0, xts))
	power(s(s(s(s(s(s(0 + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(0)), ze)
	(s(0) * power(s(0), xts)) * (s(s(0)) * power(s(s(0)), xts)) -> s(s(0)) * power(s(s(0)), xts)
	(s(s(0)) * power(s(s(0)), xts)) * (s(0) * power(s(0), xts)) -> s(s(0)) * power(s(s(0)), xts)
	power(s(s(s(s(s(s(0 + xts)) + xts)) + xts)), ze) -> power(s(s(xts)), ze) * power(s(s(s(0))), ze)
	(0 * (0 * power(0, xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> 0 * (0 * power(0, xts))
	(x * (x * (x * power(x, xts)))) * (0 * (0 * (0 * power(0, xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * power(s(0), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts)) -> s(s(s(0))) * power(s(s(s(0))), xts)
	(0 * (0 * power(0, xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> 0 * (0 * power(0, xts))
	(s(0) * (s(0) * power(s(0), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(0) * (s(0) * power(s(0), xts))
	power(s(s(s(s(s(s(s(s(s(0 + xts))) + xts))) + xts))), ze) -> power(s(s(s(xts))), ze) * power(s(s(s(0))), ze)
	(0 * (0 * (0 * power(0, xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	(s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(0) * (s(0) * power(s(0), xts))) -> s(s(0)) * (s(s(0)) * power(s(s(0)), xts))
	s(s(s(s(0)))) * (power(s(s(0)), xts) * power(s(s(0)), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))
	(0 * (0 * (0 * power(0, xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> 0 * (0 * (0 * power(0, xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(0) * (s(0) * (s(0) * power(s(0), xts)))
	(s(0) * (s(0) * power(s(0), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))
	s(s(s(s(s(s(0)))))) * (power(s(s(0)), xts) * power(s(s(s(0))), xts)) -> (s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(0) * (s(0) * (s(0) * power(s(0), xts)))) -> s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(0)) * power(s(s(0)), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))
	(s(0) * (s(0) * (s(0) * power(s(0), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * power(s(s(0)), xts)) * (s(s(s(0))) * power(s(s(s(0))), xts))) -> (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))
	s(s(s(s(0)))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) -> (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts))))
	s(s(s(s(s(s(0)))))) * ((s(s(0)) * (s(s(0)) * power(s(s(0)), xts))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts)))) -> (s(s(0)) * (s(s(0)) * (s(s(0)) * power(s(s(0)), xts)))) * (s(s(s(0))) * (s(s(s(0))) * (s(s(s(0))) * power(s(s(s(0))), xts))))
--- Primal Grammar:
+++ Presburger system  = {
	^f0(0; x, xts) -> x * xts
	^f0($n0 + 1; x, xts) -> ^f0($n0; x, xts) + x
	^f1(0; xts) -> xts
	^f1($n1 + 1; xts) -> s(^f1($n1; xts))
	^f11(0; xts) -> 0
	^f11($n11 + 1; xts) -> s(^f11($n11; xts) + xts)
	^f13(0; xts) -> power(s(0), xts)
	^f13($n13 + 1; xts) -> s(0) * ^f13($n13; xts)
	^f16(0) -> 0
	^f16($n16 + 1) -> s(s(^f16($n16)))
	^f17(0, $n7; xts) -> s(^f7($n7; xts)) + xts
	^f17($n17 + 1, $n7; xts) -> s(^f17($n17, $n7 + 1; xts))
	^f2(0; xts) -> power(0, xts)
	^f2($n2 + 1; xts) -> 0 * ^f2($n2; xts)
	^f20(0; xts) -> power(s(s(0)), xts)
	^f20($n20 + 1; xts) -> s(s(0)) * ^f20($n20; xts)
	^f26(0) -> 0
	^f26($n26 + 1) -> s(s(s(^f26($n26))))
	^f27(0, $n17; xts) -> s(^f17($n17, 0; xts)) + xts
	^f27($n27 + 1, $n17; xts) -> s(^f27($n27, $n17 + 1; xts))
	^f29(0; xts) -> power(s(s(s(0))), xts)
	^f29($n29 + 1; xts) -> s(s(s(0))) * ^f29($n29; xts)
	^f3(0; x, xts) -> power(x, xts)
	^f3($n3 + 1; x, xts) -> x * ^f3($n3; x, xts)
	^f5(0; x) -> 0
	^f5($n5 + 1; x) -> ^f5($n5; x) + x
	^f6(0) -> 0
	^f6($n6 + 1) -> s(^f6($n6))
	^f7(0; xts) -> 0 + xts
	^f7($n7 + 1; xts) -> s(^f7($n7; xts))
+++ }
+++ Lemma(s)           = 
	power(^f0($n; x, xts) + x, ze) = power(x, ze) * power(s(^f1($n; xts)), ze)
	0 * ^f2($n; xts) = (x * ^f3($n; x, xts)) * (0 * ^f2($n; xts))
	power(^f5($n; x) + x, ze) = power(x, ze) * power(s(^f6($n)), ze)
	power(^f6($n), ze) = power(^f6($n), ze) * power(s(0), ze)
	power(s(^f7($n; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(0), ze)
	power(0, ze) = power(0, ze) * power(s(^f6($n)), ze)
	power(s(^f11($n; xts) + xts), ze) = power(s(xts), ze) * power(s(^f6($n)), ze)
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(0) * ^f13($n; xts))
	^f6($n) * power(^f6($n), xts) = (^f6($n) * power(^f6($n), xts)) * (s(0) * power(s(0), xts))
	power(^f16($n), ze) = power(^f6($n), ze) * power(s(s(0)), ze)
	power(s(^f17($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(0)), ze)
	0 * power(0, xts) = (0 * power(0, xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	s(0) * ^f13($n; xts) = (s(0) * ^f13($n; xts)) * (s(0) * ^f13($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(^f6($n)) * power(s(^f6($n)), xts) = (s(0) * power(s(0), xts)) * (s(^f6($n)) * power(s(^f6($n)), xts))
	power(^f26($n), ze) = power(^f6($n), ze) * power(s(s(s(0))), ze)
	power(s(^f27($n, 0; xts)), ze) = power(s(^f1($n; xts)), ze) * power(s(s(s(0))), ze)
	s(s(0)) * ^f20($n; xts) = (s(s(0)) * ^f20($n; xts)) * (s(0) * ^f13($n; xts))
	s(s(0)) * ^f20($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(0)) * ^f20($n; xts))
	0 * ^f2($n; xts) = (0 * ^f2($n; xts)) * (s(s(s(0))) * ^f29($n; xts))
	s(s(s(s(0)))) * (^f20($n; xts) * ^f20($n; xts)) = (s(s(0)) * ^f20($n; xts)) * (s(s(0)) * ^f20($n; xts))
	s(s(s(0))) * ^f29($n; xts) = (s(0) * ^f13($n; xts)) * (s(s(s(0))) * ^f29($n; xts))
	s(s(s(s(s(s(0)))))) * (^f20($n; xts) * ^f29($n; xts)) = (s(s(0)) * ^f20($n; xts)) * (s(s(s(0))) * ^f29($n; xts))

+++ SUCCESS: all conjectures proved
+++ Statistics:
... Number of proof steps          = 56
... Number of induction steps      = 56
... Number of equational steps     = 0
... Number of case rewriting steps = 0
... Number of PG defined symbols   = 15
... Number of PG lemmas            = 23
... Elapsed time (seconds)         = 20.05
